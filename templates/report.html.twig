{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1 class="page-title">Redovisning</h1>
        <article> 
            <div class="kmom-link-div">
                <a class="kmom-link" href="/report#kmom01">kmom01</a>
                <a class="kmom-link" href="/report#kmom02">kmom02</a>
                <a class="kmom-link" href="/report#kmom03">kmom03</a>
                <a class="kmom-link" href="/report#kmom04">kmom04</a>
                <a class="kmom-link" href="/report#kmom05">kmom05</a>
                <a class="kmom-link" href="/report#kmom06">kmom06</a>
                <a class="kmom-link" href="/report#kmom07/10">kmom07/10</a>
            </div>
     
            <h2 id="kmom01">kmom01 - Redovisning</h2>
            <p>
                Mina tidigare kunskaper inom objektorientering kommer främst från er kurs OOP i Python.
                Jag har tidigare sett och arbetat med klasser och objektorienterad programmering i Python och har en grundläggande förståelse för vad det innebär, tror jag.
                Det ska bli spännande att fortsätta utforska skillnaderna och hur det fungerar annorlunda i Python.
                <br>
                <br>
                För att läsa på om klasser och objekt i PHP valde jag istället: https://www.w3schools.com/php/php_oop_what_is.asp
                <br>
                Det är min favoritsida, eftersom jag ofta tycker att andra guider innehåller för mycket onödig information, medan w3schools går rakt på sak.

                PHP:s modell för klasser innebär att de definieras med nyckelordet class, följt av klassens namn.
                Innehållet i klassen omges av måsvingar ({}) precis som i många andra språk.
                Metoder och attribut i klasser kan deklareras som public eller private, och precis som i Python kan de användas när ett objekt har skapats.
                Likt Python har PHP konstruktorer, arv (vilket jag använde i en av mina controllers), och man ärver med nyckelordet extends.
                Nyckelordet $this fungerar som self i Python och refererar till det aktuella objektet.
                Abstrakta klasser, statiska metoder med mera som finns i Python OOP återfinns även här.
                Jag läste också om traits, som verkar fungera som ett alternativ till multipelt arv, eftersom PHP bara tillåter arv från en klass.
                <br>
                <br>
                Jag upplevde kodbasen som något förvirrande.
                Jag hade inga problem att få det att fungera, och jag förstår att en controller i PHP tillsammans med Symfony är en form av specificerad route som utför viss logik.
                Jag förstår också att $this->render renderar vår .twig-fil på liknande sätt som Flask gör med Jinja2.
                Det enda jag hade svårt att förstå var själva controllern; jag funderade över: "Controllern är ju en klass som aldrig instansieras — då måste Symfony göra det åt mig på något sätt?"
                Det fick jag senare bekräftat — om jag har förstått det rätt så instansierar Symfony controllern via ramverket.
                <br>
                <br>
                Jag ska vara ärlig och säga att jag mest skummade igenom "PHP The Right Way".
                Att läsa om kod, särskilt långa textstycken om sådant man inte behöver just nu, fastnar inte riktigt hos mig.
                Det som gör att jag lär mig ett programmeringsspråk är att själv testa funktioner jag precis har hittat.
                Det är bland annat därför jag gillar w3schools, eftersom de håller texterna korta och erbjuder möjlighet att direkt testa koden på deras sida.
                <br>
                <br>
                Min största TIL (Today I Learned) är vad som menas med MVC – Model View Controller.
                Model förstår jag som en PHP-klass som representerar och hanterar logik.
                View är det som ansvarar för att visa information till användaren, exempelvis en .twig-fil.
                Controller är också en PHP-klass som i mitt fall tar emot förfrågningar på en viss route, kör logiken och skickar vidare till vyn (.twig-filen).
            </p>
            <h2 id="kmom02">kmom02 - Redovisning</h2>
            <p>
                Arv i OOP innebär att en klass ärver från en annan klass.
                Att ärva betyder att den nya klassen (B) automatiskt får tillgång till attribut och metoder från den gamla klassen (A).
                På så sätt kan man skapa en ny klass (B) med utökad funktionalitet jämfört med originalet (A).
                <br>
                <br>
                Komposition i OOP innebär att en klass byggs upp med hjälp av en annan klass.
                Som i min klass DeckOfCards, som är uppbyggd med hjälp av min andra klass CardGraphic, där varje kort i kortleken utgörs av en instans av CardGraphic.
                <br>
                <br>
                Interface i PHP OOP är ett sätt att definiera hur en klass ska implementeras.
                Ett interface säkerställer att alla klasser som implementerar det innehåller de metoder som anges i interfacet.
                <br>
                <br>
                Trait i PHP löser problemet med att en klass inte kan ärva från mer än en annan klass.
                Eftersom PHP endast tillåter enkel arv kan man använda en eller flera traits för att återanvända kod i olika klasser.
                På så sätt kan man kringgå begränsningen av enkel arv i PHP.
                
            </p>
            <p>
                Jag är 6/10 nöjd med min implementering av uppgiften.
                Jag löste uppgiften till stor del genom att utgå från övningen med tärningar, med en controller för alla card-routes och en för API:et.
                <br>
                <br>
                Min klass CardGraphic gör inte mycket mer än att ärva från Card, för att uppfylla arvskravet, vilket jag troligen kommer att ändra framöver.
                Samma gäller klassen CardHand – jag hade planer för att använda den men insåg att jag kunde lösa allt med DeckOfCards.
                <br>
                <br>
                Detta kommer jag också att ändra framöver så att CardHand faktiskt används.
                I övrigt tycker jag att min implementering är acceptabel.
            </p>
            <p>
                Jag tycker ändå att PHP är intressant.
                Jag är van vid Python och JavaScript, så PHP känns som ett språk som vill sticka ut lite och göra saker på sitt eget sätt.
                Men jag gillar det.
                <br>
                <br>
                Det känns som att PHP har många smidiga hjälpmetoder, och det är rätt intressant att läsa dess dokumentation.
                Symfony känns som ett stabilt ramverk, men precis som PHP gör det saker på sitt eget sätt jämfört med Flask och Express.
                <br>
                <br>
                Detta kursmoment kändes ibland lite mastigt, men jag hade roligt större delen av tiden.
                Det fanns även stunder då det uppstod en del frustration.
                <br>
                <br>
                Min TIL detta kmom är interfaces.
                Traits kikade jag lite på förra veckan, så jag hade redan viss koll på dem.
            </p>
            
        
            <h2 id="kmom03">kmom03 - Redovisning</h2>
             <p>
                Jag tycker att både pseudokod och flödesdiagram är praktiska. 
                Kanske inte i början som en exakt ritning över hur det ska se ut eftersom det förmodligen kommer finnas problem och annat man stöter på under själva skapandet av programmet. 
                Men definitivt som en första utskrift på ungefär hur det ska se ut och vad man behöver tänka på. 
                Jag har sedan innan lekt lite med pseudokod, testat mig fram, för att se vad jag tycker fungerar bäst för mig. 
                Och jag tycker definitivt att det finns fördelar med att sätta sig ner och skriva ut det man ska göra innan man gör det.
                <br>
                <br>
                Jag löste det hela främst med att skapa en klass som representerar en omgång av spelet tjugoett. 
                Denna klass, CardGame-klassen, tar in både spelarens hand respektive bankens hand (i rätt ordning) och använder sig av en och samma kortlek, precis som i verkligheten. 
                Jag tycker ändå att jag har löst det hela på ett ganska så bra sätt. 
                Tidigare har jag hört att klasser ska oftast representera något från verkligheten, så att skapa en klass som representerar en omgång kändes väldigt logiskt. 
                Kan koden göras bättre? 
                Absolut, men jag är nöjd med hur den är nu. 
                Det enda som verkligen störde mig detta kursmomentet var lintern som klagade på en del saker som jag inte tyckte var rimliga. 
                Den ville till exempel inte att jag använder mig av $_SERVER-variabeln, vilket jag inte köpte. 
                Det kanske finns en bra anledning till det som jag inte känner till än, men jag valde att inte lyssna på lintern där. 
                Sedan var även många av felen från tidigare kursmoment, tidigare klasser och controllers, då vi inte körde lintern än, som jag tänker fixa under kommande kursmoment från och till. 
                Jag valde först och främst att se till att all kod från detta kursmomentet, där jag och lintern var överens, var korrekt.
                <br>
                <br>
                Generellt sett så gillar jag Symfony och jag börjar även få lite mersmak för PHP. 
                Jag gillar uppsättningen vi har just nu med controllers, klasser, templates osv. 
                Jag har även börjat förstå vad en del av felen är när Symfony spottar ut dem vilket innebär att jag kan korrigera dem och få hemsidan körandes igen snabbt vilket gör det roligare.
                <br>
                <br>
                Detta kursmoment så är väl egentligen det nya som introducerades phpmd och PHPstan, så det är väl det som jag har lärt mig. 
                I övrigt har det varit en väldigt bra repetition i allt vi har lärt oss hittills och jag känner att jag har fått möjligheten att gjuta in Symfonys tillvägagångssätt lite mer. 
                Jag har även fått tänka väldigt mycket själv, främst i hur jag ska lösa uppgiften, vilket jag känner främjar ens egen utveckling mycket.
            </p>
            <h2 id="kmom04">kmom04 - Redovisning</h2>
             <p>
                Jag tyckte att det var roligt att få testa min egen kod.
                Även om koden kanske inte är särskilt avancerad känns det som en perfekt övning för att få prova på testning (även om jag skrev några tester i OOP-kursen också).
                Jag upplever PHPunit som ett bra verktyg, och jag gillar verkligen coverage-sidan som den genererar, eftersom den ger en bra överblick över hur stor del av koden som är testad.
                <br>
                <br>
                På mina modellklasser lyckades jag nå 100 % täckning.
                Det stämmer nog, som det sades på föreläsningen, att det är en sak att testa sin egen kod jämfört med att någon annan gör det.
                Jag tyckte det var ganska enkelt att testa det jag anser att koden borde klara av.
                <br>
                <br>
                Jo, jag upplever min kod som testbar, och det finns säkert många fler sätt att testa den på.
                Den del som troligen är minst testbar är min Card-klass, som inte är särskilt stor – den tar bara tre argument i konstruktorn och har en metod som returnerar kortets färg och värde som en sträng.
                Det finns säkert fler tester man kan skriva för Card-klassen, men det är nog den del av min kod som är minst testbar.
                <br>
                <br>
                Nej, generellt behöll jag min kod som den var tidigare när det gäller testning.
                Däremot lade jag många timmar på att få PHPstan att acceptera min kod vid omskrivning.
                Jag löste alla fel från PHPstan och det mesta från PHPmd, men PHPmd klagar fortfarande på några punkter som jag inte tycker är rimliga.
                Jag fick lägga mycket tid på att felsöka och förstå vad det faktiskt var PHPstan klagade på, och det tog ett tag att förstå dokumentationen, särskilt kring "No value type specified in iterable type" på https://PHPstan.org/blog/solving-PHPstan-no-value-type-specified-in-iterable-type och hur man hanterar om json_encode() returnerar false.
                Det visade sig att om man manuellt ger den en JSON-sträng när den returnerar false, så accepterar PHPstan det – vilket kanske är logiskt i efterhand.
                Generellt tycker jag att både PHPstan och PHPmd är rimliga, till exempel att PHPstan är noga med att det som hämtas från sessionen verkligen är en sträng och att när den "avserialiserats" så kontrolleras att det är en instans av rätt klass vars metoder jag använder längre ner i koden.
                <br>
                <br>
                Ja, det skulle jag nog säga.
                Snygg och ren kod är lättläst, vilket gör det enklare att följa flödet och därmed också att hitta eventuella fallgropar.
                <br>
                <br>
                Veckans TIL är dokumentation med PHPdoc samt testverktyget PHPunit.
                Jag är sedan tidigare van vid JSDoc, och PHPdoc är väldigt likt – än så länge i alla fall.
                Även PHPunit och Pythons unittest liknar varandra en hel del.
                Så den här veckan kändes det som att jag fick bygga vidare på mina kunskaper i JSDoc och unittest, samtidigt som jag fick en introduktion till dokumentation och testning i PHP.
            </p>
            <h2 id="kmom05">kmom05 - Redovisning</h2>
             <p>
                Det gick bra, tycker jag.
                Det enda jag kände främst var en tacksamhet över att det finns objekt-relationella mappare som förenklar arbetet med relationsdatabaser.
                Jag känner till Sequelize sedan tidigare, så själva konceptet med Doctrine förstod jag snabbt.
                <br>
                <br>
                Det jag tänkte främst på var att inte krångla till det.
                Man kan säkert lösa uppgifterna på många olika sätt, men jag valde att hålla mig till den struktur och arbetsmetod jag använt i tidigare kursmoment.
                När det gäller användargränssnittet var målet bara att skapa en design som kändes respektabel och rimlig.
                Man kan lätt lägga mycket tid på designen om det finns utrymme för det, vilket är anledningen till att jag försökte fokusera mer på logiken i backend.
                <br>
                <br>
                Det gick absolut bra att jobba med CRUD-funktionalitet tillsammans med ORM.
                Doctrine är väldigt smidigt, det förenklar mycket och minskar mängden logik som behöver skrivas i controllern.
                Jämfört med tidigare kurser där vi skrivit SQL-frågor direkt, är Doctrine ett betydligt mer praktiskt alternativ.
                Att skriva ren SQL-kod kan bli rätt rörigt enligt min erfarenhet, så att istället jobba mot en klass med inbyggda metoder gjorde koden renare och mer lättläst.
                <br>
                <br>
                Som jag nämnt tidigare är min uppfattning att det är väldigt trevligt.
                Det förenklar arbetet och minskar mängden kod som behöver skrivas, rejält i min mening.
                Och förutom att skriva SQL direkt i backend som man skickar som en förfrågan, är jag osäker på vilka andra sätt man kan arbeta mot databaser.
                Något jag märkt över tid är att det alltid finns flera olika lösningar på ett problem, och alla har sina fördelar och nackdelar.
                Så det finns nog definitivt fler sätt att jobba på.
                <br>
                <br>
                Det är Doctrine som helhet.
                Jag hade kanske kunnat ana att Symfony har en dedikerad ORM, som många andra ramverk, men jag hade inte hört talas om Doctrine innan.
                Doctrine var en positiv överraskning, och om jag väljer att fortsätta arbeta med PHP och Symfony på min fritid – vilket jag överväger – så kommer jag definitivt fortsätta använda Doctrine för att kommunicera med SQL-databasen.
                
            </p>
            <h2 id="kmom06">kmom06 - Redovisning</h2>
             <p>
                Jag uppfattade PHPmetrics som ett väldigt användbart verktyg.
                Den del jag använde mest var sektionerna för komplexitet och defekter.
                Det är sådana här verktyg som, när man har jobbat med dem ett tag, verkligen bidrar till att man utvecklas som programmerare, tror jag.
                De hjälper en att upptäcka vilka dåliga vanor eller tendenser man har i sin kod.
                Med tiden lär man sig vad som ofta kritiseras – jag har till exempel, efter flera rundor med PHPmetrics, 
                insett att jag behöver bli bättre på att lyfta ut funktionalitet ur mina lösningar för att göra koden mer lättläst och underhållsvänlig.
                <br>
                <br>
                Scrutinizer har jag blivit ett stort fan av, just att den ger betyg på ens olika filer och att det kopplas ihop med ens Github repo är riktigt bra.
                Det gick väldigt lätt och bra att integrera Scrutinizer och den uppdateras fint efter varje push.
                Kodtäckning var 16% och kodkvalitet låg på 9.16 efter första bygget.
                <br>
                <br>
                Jag tror definitivt att man kan påvisa kodkvalitet till viss del via badges och annat.
                Men sedan så tror jag att kod, precis som mycket annat, kan vara gråzoner och testare så som phpstan, phpmd, phpmetrics och scrutnizer jobbar mer i svart eller vitt.
                Jag har, som nämnt i tidigare kursmoment, valt att ignorera vissa saker som testerna har klagat på eftersom jag uppfatta det inte som så svart och vitt som testerna påstod att det var.
                Jag tror det är en viktigt sak att ha i åtanke när man använder sig av dessa hjälpprogram.
                <br>
                <br>
                Min TIL denna veckan är vertygen phpmetrics och scrutinizer.
                Dessutom har jag fått lära mig mer om CI och CD.
                Det är inte första gången som jag har stött på dem men det känns som att jag har fått större förståelse nu.
                Sedan har jag även lärt mig om de 6C:na.
            </p>
            <h2 id="kmom07/10">kmom07/10 - Redovisning</h2>
             <p>
                The standard Lorem Ipsum passage, used since the 1500s
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
                Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 
                Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
                Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."

                Section 1.10.32 of "de Finibus Bonorum et Malorum", written by Cicero in 45 BC
                "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, 
                eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. 
                Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. 
                Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? 
                Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, 
                vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"

                1914 translation by H. Rackham
                "But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and 
                I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, 
                the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, 
                but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. 
                Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, 
                but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. 
                To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? 
                But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, 
                or one who avoids a pain that produces no resultant pleasure?"

                Section 1.10.33 of "de Finibus Bonorum et Malorum", written by Cicero in 45 BC
                "At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque 
                corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, 
                similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. 
                Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, 
                cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, 
                omnis voluptas assumenda est, omnis dolor repellendus. 
                Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates 
                repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, 
                ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat."

                1914 translation by H. Rackham
                "On the other hand, we denounce with righteous indignation and dislike men who are so beguiled and demoralized 
                by the charms of pleasure of the moment, so blinded by desire, that they cannot foresee the pain and trouble that are bound to ensue; 
                and equal blame belongs to those who fail in their duty through weakness of will, which is the same as saying through shrinking from toil and pain. 
                These cases are perfectly simple and easy to distinguish. In a free hour, when our power of choice is untrammelled and when nothing prevents our 
                being able to do what we like best, every pleasure is to be welcomed and every pain avoided. But in certain circumstances and owing to the 
                claims of duty or the obligations of business it will frequently occur that pleasures have to be repudiated and annoyances accepted. 
                The wise man therefore always holds in these matters to this principle of selection: he rejects pleasures to secure other greater pleasures, 
                or else he endures pains to avoid worse pains."
            </p>
        </article>
    </main>
{% endblock %}